import pygame
import os
import glob

# --- Setup ---
pygame.init()
windowed_size = (800, 600)
screen = pygame.display.set_mode(windowed_size, pygame.RESIZABLE)
pygame.display.set_caption("Tile Grid with Foreground Collision")
clock = pygame.time.Clock()

# --- Load and scale tile images ---
def load_tile(filename, size):
    path = os.path.join('Images', 'sprites', filename)
    try:
        image = pygame.image.load(path).convert_alpha()
        return pygame.transform.scale(image, size)
    except Exception as e:
        print(f"Error loading {filename}: {e}")
        return pygame.Surface(size, pygame.SRCALPHA)


def load_foreground_any(size, preferred="ground_greye.png"):
    pref_path = os.path.join('Images', 'sprites', preferred)
    if os.path.exists(pref_path):
        return load_tile(preferred, size)

    # Search for any foreground_*.png
    candidates = glob.glob(os.path.join('Images', 'sprites', 'foreground_*.png'))
    candidates.sort()
    if candidates:
        try:
            img = pygame.image.load(candidates[0]).convert_alpha()
            return pygame.transform.scale(img, size)
        except Exception as e:
            print(f"Error loading {candidates[0]}: {e}")

    # Fallback placeholder
    surf = pygame.Surface(size, pygame.SRCALPHA)
    surf.fill((120, 80, 40))
    pygame.draw.rect(surf, (80, 50, 20), surf.get_rect(), 2)
    return surf
    
# --- Dynamic tile sizing ---
def get_tile_sizes(screen_size):
    sw, _ = screen_size
    small = int(sw * 0.05)
    large = int(sw * 0.10)
    return (small, small), (large, large)

# --- Tile class with mask ---
class Tile:
    def __init__(self, image, x, y):
        self.image = image
        self.rect = image.get_rect(topleft=(x, y))
        self.mask = pygame.mask.from_surface(image)

    def draw(self, surface, offset):
        # offset is a Vector2 (camera offset). Compute integer screen position.
        pos = (int(self.rect.x + offset.x), int(self.rect.y + offset.y))
        surface.blit(self.image, pos)

    def collides_with(self, other_rect, other_mask, offset):
        # Compute other mask position relative to this tile's mask.
        # Both self.rect are world coords; other_rect is in screen coords, so use offset (camera) to convert.
        # self_screen = (self.rect.x + offset.x, self.rect.y + offset.y)
        # other_screen = (other_rect.x, other_rect.y)
        # relative = (other_screen.x - self_screen.x, other_screen.y - self_screen.y)
        rel_x = int(other_rect.x - (self.rect.x + offset.x))
        rel_y = int(other_rect.y - (self.rect.y + offset.y))
        return self.mask.overlap(other_mask, (rel_x, rel_y)) is not None

# --- Grid overlay ---
def draw_grid(surface, rows, cols, cell_size, offset):
    for r in range(rows + 1):
        pygame.draw.line(surface, (50, 50, 50),
                         (offset.x, offset.y + r * cell_size),
                         (offset.x + cols * cell_size, offset.y + r * cell_size))
    for c in range(cols + 1):
        pygame.draw.line(surface, (50, 50, 50),
                         (offset.x + c * cell_size, offset.y),
                         (offset.x + c * cell_size, offset.y + rows * cell_size))

# --- Helper for large tile placement ---
def is_top_left_of_large_tile(row, col, cell, grid_map):
    return (
        (row == 0 or grid_map[row - 1][col] != cell) and
        (col == 0 or grid_map[row][col - 1] != cell)
    )

# --- Build tile objects from grid ---
def build_tiles(grid_map, small_size):
    tiles = []
    for row in range(len(grid_map)):
        for col in range(len(grid_map[0])):
            cell = grid_map[row][col]
            if cell is None:
                continue
            w, h = cell.get_size()
            x = col * small_size[0]
            y = row * small_size[0]
            if w > small_size[0] or h > small_size[1]:
                if is_top_left_of_large_tile(row, col, cell, grid_map):
                    tiles.append(Tile(cell, x, y))
            else:
                tiles.append(Tile(cell, x, y))
    return tiles

# --- Initial sizes and assets ---
small_size, large_size = get_tile_sizes(windowed_size)
# --- Key tokens so templates can use unquoted identifiers like AA, BA, FG ---
class Key:
    def __init__(self, name: str):
        self.name = name
    def __repr__(self):
        return f"Key({self.name!r})"

AA = Key('AA')
BA = Key('BA')
BB = Key('BB')
FG = Key('FG')
# additional foreground tile keys (two-letter tokens starting with F)
FA = Key('FA')  # center.png
FB = Key('FB')  # curve_in_bl.png
FC = Key('FC')  # curve_in_br.png
FD = Key('FD')  # curve_in_tl.png
FE = Key('FE')  # curve_in_tr.png
FF = Key('FF')  # curve_out_bl.png
FH = Key('FH')  # curve_out_br.png (note: original name had a typo 'curve_ou_br')
FI = Key('FI')  # roof.png
FJ = Key('FJ')  # wall_left_1.png
FK = Key('FK')  # wall_left_2.png
FL = Key('FL')  # wall_right_1.png
FM = Key('FM')  # wall_right_2.png
NA = None

# Load surfaces into a mapping so templates that use Key(...) can be resolved.
def load_tile_surfaces(small_size, large_size):
    return {
        'AA': load_tile("Basic Tile.png", small_size),
        'BA': load_tile("Basic Tile Claw Mark.png", large_size),
        'BB': load_tile("Basic Tile Hole.png", large_size),
        'FG': load_tile("ground_grey.png", small_size),
        # foreground-specific tiles (two-letter F* keys)
        'FA': load_tile("center.png", small_size),
        'FB': load_tile("curve_in_bl.png", small_size),
        'FC': load_tile("curve_in_br.png", small_size),
        'FD': load_tile("curve_in_tl.png", small_size),
        'FE': load_tile("curve_in_tr.png", small_size),
        'FF': load_tile("curve_out_bl.png", small_size),
        'FH': load_tile("curve_out_br.png", small_size),
        'FI': load_tile("roof.png", small_size),
        'FJ': load_tile("wall_left_1.png", small_size),
        'FK': load_tile("wall_left_2.png", small_size),
        'FL': load_tile("wall_right_1.png", small_size),
        'FM': load_tile("wall_right_2.png", small_size),
    }

assets = load_tile_surfaces(small_size, large_size)

# --- Map templates (single source of truth) ---
# Use short keys in templates; we'll resolve them to loaded surfaces with resolve_map().
grid_template = [
    [AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA],
    [AA, BA, NA, AA, AA, AA, BA, NA, AA, AA, AA, BA, NA, AA, AA, AA, BA, NA, AA, AA],
    [AA, NA, NA, AA, AA, AA, NA, NA, AA, AA, AA, NA, NA, AA, AA, AA, NA, NA, AA, AA],
    [AA, AA, AA, BB, NA, AA, AA, AA, BB, NA, AA, AA, AA, BB, NA, AA, AA, AA, BB, NA],
    [AA, AA, AA, NA, NA, AA, AA, AA, NA, NA, AA, AA, AA, NA, NA, AA, AA, AA, NA, NA],
    [AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA, AA],
]

foreground_template = [
    [FD, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA],
    [NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA],
    [NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA],
    [NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA],
    [NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA],
    [FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG, FG],
]


def resolve_map(template, key_map):
        #Return a new map where keys in the template are replaced by surfaces from key_map.

        #template: 2D list with strings (keys) or None
        #key_map: dict mapping keys to pygame.Surface
    
    out = []
    for row in template:
        out_row = []
        for cell in row:
            # allow templates to contain Key tokens, strings, or already-resolved Surfaces
            if cell is None:
                out_row.append(None)
            elif isinstance(cell, str):
                out_row.append(key_map.get(cell))
            elif hasattr(cell, 'name'):
                # Key-like object
                out_row.append(key_map.get(cell.name))
            else:
                # assume this is already a Surface or similar
                out_row.append(cell)
        out.append(out_row)
    return out

# resolve initial maps using loaded assets
grid_map = resolve_map(grid_template, assets)
foreground_map = resolve_map(foreground_template, assets)

background_tiles = build_tiles(grid_map, small_size)
foreground_tiles = build_tiles(foreground_map, small_size)


def save_templates_to_file():
    """Serialize grid_template and foreground_template back into this python file.
    This will overwrite the list literals for `grid_template` and `foreground_template` in-place.
    A backup of the original file will be written with a .bak suffix.
    """
    import io, time
    path = os.path.abspath(__file__)

    def row_to_code(row):
        parts = []
        for cell in row:
            if cell is None:
                parts.append('NA')
            elif hasattr(cell, 'name'):
                parts.append(cell.name)
            else:
                # Fallback: try to find key name in assets by identity
                found = None
                for k, v in assets.items():
                    if v is cell:
                        found = k
                        break
                parts.append(found or 'NA')
        return '    [' + ', '.join(parts) + '],\n'

    def template_to_block(template):
        s = '[\n'
        for row in template:
            s += row_to_code(row)
        s += ']'
        return s

    grid_code = template_to_block(grid_template)
    fg_code = template_to_block(foreground_template)

    with open(path, 'r', encoding='utf-8') as f:
        src = f.read()

    def replace_var(src, varname, code_block):
        # find varname = and the following '[' start
        marker = varname + ' ='
        idx = src.find(marker)
        if idx == -1:
            return src
        start = src.find('[', idx)
        if start == -1:
            return src
        i = start
        depth = 0
        end = None
        while i < len(src):
            if src[i] == '[':
                depth += 1
            elif src[i] == ']':
                depth -= 1
                if depth == 0:
                    end = i
                    break
            i += 1
        if end is None:
            return src
        # keep same indentation as original by inserting newline where start was
        new_src = src[:start] + code_block + src[end+1:]
        return new_src

    new_src = replace_var(src, 'grid_template', grid_code)
    new_src = replace_var(new_src, 'foreground_template', fg_code)

    # write backup then overwrite
    bak_path = path + '.bak'
    with open(bak_path, 'w', encoding='utf-8') as f:
        f.write(src)
    with open(path, 'w', encoding='utf-8') as f:
        f.write(new_src)


# --- Player setup ---
# Player is two small tiles tall and one wide
player_size = (small_size[0], small_size[1] * 2)
try:
    player_image = load_tile('test_player.png', player_size)
except Exception:
    # fallback placeholder
    player_image = pygame.Surface(player_size, pygame.SRCALPHA)
    player_image.fill((200, 180, 120))
    pygame.draw.rect(player_image, (120, 90, 60), player_image.get_rect(), 2)

player_rect = player_image.get_rect(topleft=(100, 100))
player_mask = pygame.mask.from_surface(player_image)

# Movement state
vel = pygame.Vector2(0, 0)
speed = 4
gravity = 0.6
jump_speed = -11
on_ground = False

def resolve_player_collisions(dx, dy):
    """Move player by dx,dy and resolve collisions with foreground_tiles using masks.
    This performs AABB checks first for speed, then mask.overlap to confirm pixel collision.
    Returns tuple (landed:boolean) indicating if player is standing on something after vertical move.
    """
    landed = False
    # horizontal move
    if dx != 0:
        player_rect.x += dx
        for tile in foreground_tiles:
            if player_rect.colliderect(tile.rect):
                # compute mask-relative offset
                rel = (player_rect.x - tile.rect.x, player_rect.y - tile.rect.y)
                if tile.mask.overlap(player_mask, rel):
                    # resolve by pushing out along x
                    if dx > 0:
                        player_rect.right = tile.rect.left
                    else:
                        player_rect.left = tile.rect.right

    # vertical move
    if dy != 0:
        player_rect.y += dy
        for tile in foreground_tiles:
            if player_rect.colliderect(tile.rect):
                rel = (player_rect.x - tile.rect.x, player_rect.y - tile.rect.y)
                if tile.mask.overlap(player_mask, rel):
                    if dy > 0:
                        # falling, land on top
                        player_rect.bottom = tile.rect.top
                        landed = True
                        vel.y = 0
                    elif dy < 0:
                        # hit head
                        player_rect.top = tile.rect.bottom
                        vel.y = 0
    return landed

# --- Main loop ---
camera_offset = pygame.Vector2(0, 0)
scroll_speed = 10
show_grid = True
fullscreen = False
camera_follows = True
running = True
# Editor state
editor_mode = False
editing_foreground = False  # if True edit foreground_template, else grid_template
# order of editable keys (two-letter names) for selection with + / -
key_order = ['AA', 'BA', 'BB', 'FG', 'FA', 'FB', 'FC', 'FD', 'FE', 'FF', 'FH', 'FI', 'FJ', 'FK', 'FL', 'FM']
selected_idx = 0

# map key names to Key tokens so templates can be assigned without quotes
key_token_map = {k: globals().get(k) for k in key_order}
# help visibility
show_help = True

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT or (
            event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_g:
                show_grid = not show_grid
            elif event.key == pygame.K_c:
                # toggle camera follow mode
                camera_follows = not camera_follows
            elif event.key == pygame.K_f:
                fullscreen = not fullscreen
                if fullscreen:
                    info = pygame.display.Info()
                    screen = pygame.display.set_mode((info.current_w, info.current_h), pygame.FULLSCREEN)
                else:
                    screen = pygame.display.set_mode(windowed_size, pygame.RESIZABLE)
                small_size, large_size = get_tile_sizes(screen.get_size())
                # reload assets at the new size and rebuild maps
                assets = load_tile_surfaces(small_size, large_size)
                grid_map = resolve_map(grid_template, assets)
                foreground_map = resolve_map(foreground_template, assets)
                background_tiles = build_tiles(grid_map, small_size)
                foreground_tiles = build_tiles(foreground_map, small_size)
            elif event.key == pygame.K_d:
                # toggle editor mode
                editor_mode = not editor_mode
                # when entering editor, stop camera follow so arrow keys pan
                if editor_mode:
                    prev_camera_follows = camera_follows
                    camera_follows = False
                else:
                    # restore camera follow
                    camera_follows = True
            elif event.key == pygame.K_h:
                show_help = not show_help
            elif event.key == pygame.K_t:
                # toggle editing layer between grid_template and foreground_template
                editing_foreground = not editing_foreground
            elif event.key in (pygame.K_EQUALS, pygame.K_PLUS):
                # next tile
                selected_idx = (selected_idx + 1) % len(key_order)
            elif event.key == pygame.K_MINUS:
                selected_idx = (selected_idx - 1) % len(key_order)
            elif event.key == pygame.K_s:
                # save templates back into this python file (overwrite definitions)
                try:
                    save_templates_to_file()
                    print('Templates saved to file')
                except Exception as e:
                    print('Failed to save templates:', e)

        elif event.type == pygame.VIDEORESIZE:
            screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)
            small_size, large_size = get_tile_sizes((event.w, event.h))
            # reload assets at the new size and rebuild maps
            assets = load_tile_surfaces(small_size, large_size)
            grid_map = resolve_map(grid_template, assets)
            foreground_map = resolve_map(foreground_template, assets)
            background_tiles = build_tiles(grid_map, small_size)
            foreground_tiles = build_tiles(foreground_map, small_size)
        elif event.type == pygame.MOUSEBUTTONDOWN and editor_mode:
            # place or erase tiles in the active template
            mx, my = event.pos
            # convert to world coords
            wx = mx - camera_offset.x
            wy = my - camera_offset.y
            col = int(wx // small_size[0])
            row = int(wy // small_size[1])
            # pick the active template
            template = foreground_template if editing_foreground else grid_template
            if 0 <= row < len(template) and 0 <= col < len(template[0]):
                if event.button == 1:
                    # left click: place selected tile token
                    token_name = key_order[selected_idx]
                    token = key_token_map.get(token_name)
                    template[row][col] = token
                elif event.button == 3:
                    # right click: clear
                    template[row][col] = NA
                # after modification rebuild resolved maps and tiles
                grid_map = resolve_map(grid_template, assets)
                foreground_map = resolve_map(foreground_template, assets)
                background_tiles = build_tiles(grid_map, small_size)
                foreground_tiles = build_tiles(foreground_map, small_size)

    keys = pygame.key.get_pressed()
    # camera controls
    if editor_mode:
        # in editor mode, arrow keys pan the camera directly
        if keys[pygame.K_LEFT]:
            camera_offset.x += scroll_speed
        if keys[pygame.K_RIGHT]:
            camera_offset.x -= scroll_speed
        if keys[pygame.K_UP]:
            camera_offset.y += scroll_speed
        if keys[pygame.K_DOWN]:
            camera_offset.y -= scroll_speed
    else:
        # camera controls (Shift + arrows) when camera isn't following the player
        if not camera_follows:
            if keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]:
                if keys[pygame.K_LEFT]:
                    camera_offset.x += scroll_speed
                if keys[pygame.K_RIGHT]:
                    camera_offset.x -= scroll_speed
                if keys[pygame.K_UP]:
                    camera_offset.y += scroll_speed
                if keys[pygame.K_DOWN]:
                    camera_offset.y -= scroll_speed

    # player input (A/D or left/right), jump with W or SPACE or UP
    move_x = 0
    if keys[pygame.K_a] or keys[pygame.K_LEFT]:
        move_x = -speed
    if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
        move_x = speed

    # apply horizontal movement and resolve collisions
    resolve_player_collisions(move_x, 0)

    # jump (only when on ground)
    if (keys[pygame.K_w] or keys[pygame.K_SPACE] or keys[pygame.K_UP]) and on_ground:
        vel.y = jump_speed

    # apply gravity
    vel.y += gravity

    # apply vertical movement and resolve collisions
    on_ground = resolve_player_collisions(0, int(vel.y))

    # camera follow: center camera on player (in world coords)
    if camera_follows:
        sw, sh = screen.get_size()
        # center player on screen
        camera_offset.x = (sw // 2) - (player_rect.x + player_rect.width // 2)
        camera_offset.y = (sh // 2) - (player_rect.y + player_rect.height // 2)

    # Editor hover preview
    hover_preview = None
    hover_pos = None
    if editor_mode:
        mx, my = pygame.mouse.get_pos()
        wx = mx - camera_offset.x
        wy = my - camera_offset.y
        col = int(wx // small_size[0])
        row = int(wy // small_size[1])
        template = foreground_template if editing_foreground else grid_template
        if 0 <= row < len(template) and 0 <= col < len(template[0]):
            token_name = key_order[selected_idx]
            surf = assets.get(token_name)
            if surf is not None:
                hover_preview = surf.copy()
                try:
                    hover_preview.set_alpha(160)
                except Exception:
                    pass
                hover_pos = (int(col * small_size[0] + camera_offset.x), int(row * small_size[1] + camera_offset.y))

    screen.fill((30, 30, 30))

    for tile in background_tiles:
        tile.draw(screen, camera_offset)

    # Draw player (apply camera offset) only when not in editor mode
    if not editor_mode:
        screen.blit(player_image, (int(player_rect.x + camera_offset.x), int(player_rect.y + camera_offset.y)))

    # Draw foreground tiles on top of the player
    for tile in foreground_tiles:
        tile.draw(screen, camera_offset)
        if tile.collides_with(player_rect, player_mask, camera_offset):
            # Draw collision rect in screen coordinates
            screen_rect = tile.rect.move(int(camera_offset.x), int(camera_offset.y))
            pygame.draw.rect(screen, (255, 0, 0), screen_rect, 2)

    # draw hover preview last so it's on top
    if hover_preview and hover_pos:
        screen.blit(hover_preview, hover_pos)

    # UI: show help and editor status (H toggles visibility)
    font = pygame.font.SysFont(None, 20)
    help_lines = [
        "D - Toggle Editor Mode (enter/exit)",
        "T - Switch Layer (Grid / Foreground)",
        "+ / - - Change selected tile",
        "Mouse L - Place tile  |  Mouse R - Erase tile",
        "S - Save templates to this python file (creates .bak backup)",
        "C - Toggle camera follow",
        "Arrow keys - Pan camera in Editor / Move player in Play",
        "Shift + Arrows - Pan camera when not following",
        "A/D or ←/→ - Player move  |  W / Space / ↑ - Jump",
        "G - Toggle grid  |  F - Toggle fullscreen",
    ]

    line_h = font.get_linesize()
    # Always show the H hint on the very top-left
    hint = f"H - {'Hide' if show_help else 'Show'} Help"
    hint_surf = font.render(hint, True, (240, 240, 120))
    screen.blit(hint_surf, (8, 8))

    # If help is enabled, render the help lines below the H hint
    top_y = 8 + line_h
    if show_help:
        for i, line in enumerate(help_lines):
            surf = font.render(line, True, (200, 200, 200))
            screen.blit(surf, (8, top_y + i * line_h))
        status_y = top_y + len(help_lines) * line_h + 4
    else:
        status_y = top_y + 4

    # draw concise status below help/hint
    status = f"MODE: {'EDITOR' if editor_mode else 'PLAY'}  LAYER: {'FOREGROUND' if editing_foreground else 'GRID'}  SELECT: {key_order[selected_idx]}"
    status_surf = font.render(status, True, (220, 220, 220))
    screen.blit(status_surf, (8, status_y))

    if show_grid:
        draw_grid(screen, len(grid_map), len(grid_map[0]), small_size[0], camera_offset)

    pygame.display.flip()
    clock.tick(60)

pygame.quit()
